{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"absolute-equal","text":"经典面试题，问起来这两者区别，更多的时候听到的回答是 === 是会比较类型， == 不会。不过进一步问 1 == [1] 返回 true 这是为什么呢？ 很多面试者就不知道怎么回答了。跟着问题，我们进一步了解下 == 和 === 的机制。 以下是 == （Abstract Equality）比较的算法： 大致翻译如下：当比较 x == y的时候 ，如果 x，y是同类型： 如果x，是 null 或者 undefined，返回 true 如果 x 是 NaN，返回 false（这就是为什么 NaN 永远不等于 NaN） 如果 x 和 y 数值相等返回 true 如果 x 是 +0 / -0 返回 true 如果 x 是字符串，x 和 y 必须完全吻合（包括字符顺序和字符串长度等） 如果 x 是 布尔型，x 和 y 需要都是 true 或者 false 如果 x ，y是不同类型 x 是 null / undefinde，y 是 undefined / null，返回 true。因为undefined是从null派生出来的。 x / y 是 数字类型，y / x 是 字符串。那么要把 y / x (非数字转数字类型) 转换成 数字类型再做比较 x / y 是布尔型，要将 x / y 转换成数字类型进行比较 如果 x 或者 y 是 Object，要用 ToPrimitive（x 或者 y）[ 对与 ToPrimitive 函数 详细描述请参考 http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toprimitive 简单浅显理解就是根据传入的参数的类型，来判断用toSring 还是 valueOf 进行转换] 转换后来进行比较。 最后 如果都不符合就返回 false 下面是‘===’比较 算法 例如如果 x === y 比较 x 和 y 类型不同，返回false 如果 x / y 同类型， x 是 null 或 undefined 返回 true … 省略N多条，因为严格比较要比较类型和数值都相等，这里没什么特殊情况。 个人理解:1：比较 {} / [] 是要比较 {} / []的指针， 指针不一样 所以 [] == [] 和 {} == {} 都返回false； 2：如果和数字比较，所有类型都要转换成数字，然后进行比较； 3：对与只有一个元素的数组，先进行 [].toString()的转换，再进行比较，如 [1].toString() // ‘1’, 然后比较 ‘1’ == true || ‘1’ == 1 最后让我们来一个经典的图。 PS： 面试时可能会碰见 类似的面试题，主要考察 js 类型的掌握程度，不求答案 100% 正确，因为在实际应用中绝大多数都用 ‘===’","link":"/absolute-equal.html"},{"title":"aem-test","text":"记一次 aem test sharing。(AEM是一个庞大的，前后端未分离的，用java各种配置的框架。)仔细查找文档发现了一些有助于 UI 测试的知识并记录。参考资料总结如下:https://blogs.perficient.com/2015/10/19/front-end-testing-with-hobbes-js/https://helpx.adobe.com/experience-manager/6-3/sites/developing/using/reference-materials/test-api/hobs.actions.core.wait.htmlhttp://www.6dglobal.com/blog/aem-hobbes-tests-a-head-start-2016-08-09https://helpx.adobe.com/experience-manager/6-3/sites/developing/using/hobbes.html","link":"/aem-test.html"},{"title":"koa-bodyparser总结","text":"koa中必不可少中间件之一A body parser for koa, base on co-body. support json, form and text type body. 基本用法disableBodyParser: 可以动态的禁用 koa-bodyparser。 和co-body 、koa-body 功能类似，使用起来看喜好。都可以限制上传文件大小，可以限制传输请求格式enableTypes（json, form, text）,formLimit默认 56kb，jsonLimit 和 textLimit 都是 1MB。所以当我们上传表单时候，要控制下大小，如果超出限制，返回413错误。encoding默认为 utf-8。原始数据放在 cxt.request.rawBody 中，解析后的数据放在 cxt.request.body 中。本例中用postman（一个发送请求的工具）发起一个格式为 Json 的 post 请求。代码中是已经使用 koa-bodyparser 解析过的，直接返回给我一个object 方便使用。 （上图为使用 postman 发送请求） （上图为服务器代码中解析后的结果） ——————————————— 相关知识分割线 ——————————————— emmm，看起来这个中间件极其简单呢，在看文档和demo过程中，对于 form-data 和 x-www-form-urlencorded 不太明白两者区别。其实 form 元素有个 enctype 属性，来指定数据编码方式： application/x-www-form-urlencoded: 窗体数据被编码为名称/值对。这是标准的编码格式。当用get请求时，编码数据会以 &amp; 符号分隔（类似 query ）写在url后。当发送post请求时，数据会放在 request body中； multipart/form-data: 表单数据编码为一条消息，每个控件对应消息的一部分。一般用于上传图片、文件等 ； text/plain: 表单数据以纯文本形式进行编码。 在developer.Mozilla.org 中关于 enctype = ‘multipart/form-data’ 的例子 关于 http header 的相关内容很多，在此不展开描述。 最后 Koa-bodyparser 简单且必要，相似的中间件有 （上图来自 https://github.com/koajs/koa/wiki#middleware） 大家可以根据需求选择一个合适的中间件。","link":"/koa-bodyparser.html"},{"title":"koa-helmet","text":"Koa-helmet 确保 koa 安全最强中间件！ 官网: https://helmetjs.github.io/ 无论前端还是后台，对安全都是极其重视的。前端同学在面试的时候常常被问到 XSS 黑客攻击手段。面试答案也很固定，其实安全防御的重点还是在服务器， koa-helmet 这个中间件能有效的防御 XSS 等攻击。这个中间件使用起来非常方便。Helmet 从14个方面守护着用户的安全，能抵挡大多数黑客攻击。本文简略的说明14种攻击类型，帮大家理解这个安全的中间件。 一: Content Security Policy（内容安全策略): 简称CSP，实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。 限制加载的类型及对应属性: CSP对应关系图: 配置方法:1.在http头中设置Content-Security-Policy字段 2.通过meta标签设置 更详细介绍请参考阮大神文章: http://www.ruanyifeng.com/blog/2016/09/csp.html 二: crossdomain 针对Adobe的 详细内容请看这里 https://www.adobe.com/devnet/adobe-media-server/articles/cross-domain-xml-for-streaming.html 这个是用来确保 Flash player 从指定服务器的获取数据的安全等。 三: dnsPrefetchControl ✓ 链接预取是一种浏览器机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。网页向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默地拉取指定的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到。虽然能起到一定的优化作用，但有用户可能泄漏自己的隐私信息。也有可能在用户不知情的情况下，偷偷自动访问另一个网站。 仅在 生效。 此中间件默认关闭连接预取。 四: expectCt for handling Certificate Transparency Expect-CT 头允许站点选择性报告和/或执行证书透明度 (Certificate Transparency) 要求，来防止错误签发的网站证书的使用不被察觉。当站点启用 Expect-CT 头，就是在请求浏览器检查该网站的任何证书是否出现在公共证书透明度日志之中。 五: featurePolicy to limit your site’s features Feature-Policy 打开或者关闭一些浏览器设备功能，比如全屏，付款，摄像等功能。而且这个功能会在潜入的iframe的网站依然生效。好在目前支持此功能的浏览器不多。不过还是要小心。 六: frameguard to prevent clickjacking ✓ 使用 frame 嵌套一个网站，通过各种手段诱使受害人点击已经是一个最简单的攻击手段。我们可以通过X-Frame-Options 来控制嵌套 iframe 的类型（同源网站／禁止嵌套／制定网站嵌套） 七: hidePoweredBy to remove the X-Powered-By header ✓ X-Powered-By 用在服务器返回 http request 的 header 中，用来指明后台用的是什么技术。但这个正好可以被黑客用来确定服务器技术并选择攻击方式。此插件将这个字段抹去，来防止黑客轻易的获取服务器技术信息。 八: hpkp for HTTP Public Key Pinning 用来防范由「伪造或不正当手段获得网站证书」造成的中间人攻击 九: hsts for HTTP Strict Transport Security ✓ 强制使用 https 协议访问当前资源。Https 相比 http 更安全。网站在http协议下更容易受到攻击。 十: ieNoOpen sets X-Download-Options for IE8+ ✓ 禁止上传下载 html 文件／可执行文件。这个仅在低版本浏览器中有这个漏洞。 十一: noCache to disable client-side caching 防止用户拿到老版本的（有缺陷的）版本。 十二: noSniff to keep clients from sniffing the MIME type ✓ MIME sniff 原本是好意，浏览器会对文件进行嗅探，看看是否写错类型的是可执行文件。如果是照样执行。在上传和下载文件的时候，都会在header中表明文件类型（content-type），如: text/javascript, text/html等。但黑客会故意上传一个文件让浏览器自动下载执行。 十三: referrerPolicy to hide the Referer header Referer header 会使网站知道用户是从哪里跳转而来。这也算用户隐私吧。 十四: xssFilter adds some small XSS protections ✓ 这个令人头痛，网上85%的黑客攻击行为都是XSS攻击，相关知识就更多了，我们在另外的文章中对XSS展开讨论，这里就不赘述。 大家一起加油！","link":"/koa-helmet.html"},{"title":"koa-jwt 全面解析，安检利器","text":"学习 Koa 不易，今天学习到了 koa-jwt 这个登陆验证必不可少的中间件。本文会说明 jwt是什么、token怎么来的、如何验证token。 一反常态，先上代码！(本代码由 koa-generater 生成，安装 koa-jwt, jsonwebtoken 两个 npm 包 ) 文件名: app.js 红色框：jwt 相关的代码 蓝色框：为了完成demo，在原有脚手架中做的调整。 文件名: routes/index.js 这里简单的模仿一个 login 请求，返回一个 token。 文件名: routes/users.js users 以下的路由需通过 jwt 验证才能访问 文件名: auth.js 思路及说明：1.我们在浏览器输入 localhost:3000/login 获取 token。一下大串都是token，分为3部分，用 ‘.’ 分隔； 2.这里用 postman 去访问 localhost:3000/users/info 模拟访问用户数据。要在 header中加入 authorization, 注意：authorization的值的格式； 3.当输入 users 路由的时候 koa-jwt 不去验证 token 的正确性，仅仅去验证header中是否有 authorization 并且值为 ‘Bearer token’，然后再根据配置中 isRevoked 的函数去进行验证。isRevoked 返回 true 表明 token 不正确，false 表示 token 正确。 4.在验证中，使用 jsonwebtoken.verify 去验证 token 是否正确，并返回。 API 解析：Koa-jwt：这个函数还是截图看得清楚 1.secret: 可以理解为一个加密因子，在生成 token 的时候用这个因子，验证 token 的时候也用同一个。Serect 可以是数组，当secret是一个数组时，在验证 token 时任何一个 因子通过验证，token就合法有效。 2.passthrough: 当为true时，即使在 header 中没有 authorization 也会通过这个 中间件（仅仅通过中间件的验证，没有通过 jsonwebtoken.verify） 3.isRevoked：需要一个函数来验证token的对错。这个函数有3个参数：ctx, decodedToken, token。其中 token 可以直接被验证： jsonwebtoken.verify(token) Jsonwebtoken:(这个才是主角！)jsonwebtoken.sign(payload, secretOrPrivateKey, [options, callback]) 生成 token 1.payload 是需要被加密的数据（我的理解 jwt其实就是加密解密和验证的过程）。在payload里有三个key很特别：iat（issued at）、exp（expiresIn）、nbf（notBefore），这几个参数推荐写在 options 中，不建议写在 payload 里； 2.secretOrPrivateKey 可以是字符串，也可以是对成加密的 key，或者非对称加密的私有key； 3.options 这里可以选择的参数就好多了，algorithms：加密算法，默认是HS256，expriesIn:token有效持续时间，notBefore: token在什么时候失效，更多参数请参考官网； 4.返回一个token。 jwt.verifyjwt.verify(token, secretOrPublicKey, [options, callback])// 对token的验证 1.token: 当然是用 sign 函数生成的token啦； 2.secretOrPublicKey: 与生成 token 的加密因子相互对应，要么是相同的字符串和对称加密的key，或者是非对称加密的公有key； 3.options: 与 sign 相互照应且要一致。audience，issuer，jwtid等。 4.正确的时候返回 payload，错误的时候throw 一个 err，里面包含了错误的message，根据message判断错误类型。 文档这里有个坑: expiredIn:默认单位是 秒！！！ 以下是铁证啊（jsonwebtoken/verify.js ，这里是用秒做的对比，千万别以为是毫秒 Tips: 通常情况下，我们也会在cookie里写一份token，这样每个请求都可以通过token验证，此时可以忽略 header中的autherization（passthrough: true）","link":"/koa-jwt.html"},{"title":"koa-router 必知必会","text":"后台服务器都绕不开路由， 所以koa-router这个中间件是一定要了解的了。Github 地址: https://github.com/alexmingoia/koa-router 以下栗子都来自官网。最后附有一些tips。 1.基本用法 技巧：const router = require(‘koa-router’)()， 引入时在最后加一个括号，直接返回一个router实例，我们就不用去写 var router = new Router() 了，一个括号省了一行代码，赚了！ 2. router.verb我们常用的 http 请求类型: get, post, put等，在router匹配这里直接可以写成 router.get(), router.post(), router.put() 来匹配。并且支持链式调用（这样分类去写review时候很方便）。 3.router 名字每个路由都可以起一个名字，这样在使用起来直接”叫”它的名字，可以省去一大串的路径。 4.router 使用中间件中间件诶，router可以用中间件，而且可以一口气用好几个中间件。不仅如此，还可以设置不同路由使用多个不同的中间件。下面第一个例子是单独对’/users/:id’ 使用一个中间件。当然还可以接着使用多个中间件。 下例是路由使用中间件的其它方法： 5.嵌套路由Kou-router 的嵌套比起 vue-router 简单多了。其实就是两个路由的直接拼接。 6.路由前缀Emmmmm 又是一个划算的代码片段，这样以后的路由就省了写’/users’ 7.查找路由router.route(): 根据路由的名字查找路由。如果存在，就反回一个layer类型的对象，结构如下。如果不存在返回false。 8.redirect 重定向重定向方法需要区别 koa-router的 router.redirect 和 koa中原来的redirect。router.redirect(source, destination, [code]): source为源路由，destination是目的路由（可以是路由名字），code需要改变ctx的状态码，默认301。源代码如下： koa原来的redirect(url, alt): url是目标url（必须是具体的url），alt是对url为’back’的特殊次处理，默认状态码302。调用时直接用 cxt.redirect 即可，源代码如下： 两个函数同一个目的，不同的参数。请选择使用。 9.router.url 静态方法返回一个具体的路径，可以配合redirect使用","link":"/koa-router.html"},{"title":"koa-static静态文件","text":"一直很想学后端技术，就是不知道如何提起兴趣，找到一个突破点。一日突然想从npm包和 koa 的中间件着手学习后端，看下后端同学思考和关心的点是什么。于是我就从npm包和中间件入手，来扒一扒后端的知识。Koa 是目前很火的 nodejs 框架，使用起来快捷方便。 如果懒的一点点窜架构，可以直接用 koa-generator脚手架很快就能搞到一个简易的框架。 1.全局安装 koa-generatornpm install -g koa-generator2. 生成框架koa2 /yourFolder 3.执行安装npm install4.启动npm start （npm start dev）5.查看浏览器查看 localhost:3000 即可 效果图： 这一步完成的很easy，接下来我们看下目录结构。 这里koa-router 和 koa-static 已经创建完成，我们只需要根据业务扩展下即可。 Koa-static 超简单的一个中间件，目的是把服务器上的一个或者多个文件夹变成静态的，然后就可以开放给所有用户查看。 在代码中我们设置了 然后我们在public文件夹下放一张1.png图片， 并在浏览器中输入 localhost:3000/1.png 注意：在浏览器中输入地址时，不需要输入’public’，安装中间件加载顺序，先去找静态文件夹public中的文件，然后再匹配路由。","link":"/koa-static.html"},{"title":"mongoDB-sharing","text":"记一次 sharing","link":"/mongoDB-sharing.html"},{"title":"给狗老板的前端入门路线","text":"～～～～～～～～～～ 学习资料 ～～～～～～～～～～ 基础教程: 1.W3cschool: https://www.w3cschool.cn/（我也不晓得什么时候有一个这样的新网站） 2.经典w3cschool: http://www.w3school.com.cn/ 学习内容:html/html5, css/css3, js, jquey, lodash等前端基础知识 视频网站: 极客学院 :https://www.jikexueyuan.com/ 注:30块一个月的VIP，先把基础课听了，然后看一些案例，照着敲一遍 慕课网: https://www.imooc.com/ 注: 这个是按课程收费，建议把免费的听完，收费的暂缓 ～～～～～～～～～～ 进阶文档 ～～～～～～～～～ 注:此区域自学能力较高，如有有视频，可以边看视频边看官方文档 Git: https://git-scm.com/ 网站内容太多了，建议看视频，别死磕，掌握常用的10-20个命令即可 Vue: https://cn.vuejs.org/v2/guide/ 前端最容易上手的框架 Vuex: https://vuex.vuejs.org/zh/ 帮助vue管理数据（vuex生态都需要看下） Reactjs: https://react.docschina.org/ 另一个很流行的框架，建议学两个就好（angular 上手不易，暂时不用了解） Redux: https://www.redux.org.cn/ 帮助 react 管理state工具 ES6: http://es6.ruanyifeng.com/ 这本书最少68块，在线免费，必看！ webpack: 建议看视频，初级前端了解就好，中高级需要会用。 ～～～～～～～～～～ 常看的技术资讯 ～～～～～～～～～～ 1.掘金: https://juejin.im/welcome/frontend 2.github: https://github.com/ 申请一个账号，有什么demo同步，全球开源网站 注:星星代表一切！！！ 3.技术趋势: https://github.com/trending 增长最快的开源代码等 4.各种技术公众号: 当然也做不到每天都刷，抽空看一眼，有感兴趣的就看看 前端之巅，前端早读课，前端大全 5.在掘金app还可以买到各种高质量小册，推荐入行后买几个感兴趣的 ～～～～～～～～～ 必备工具 ～～～～～～～～～～～ 前端工具: 1.谷歌浏览器（必备): 开发方便，兼容性好。IE/FF等会有部分兼容问题 2.visual studio code: 常用前端开发编辑器，可以安装各种插件。（另外还有webstrom和Atom，可以选择自己喜欢的， webstrom是收费的，不过应该可以有破解版） 3.npm: node:https://nodejs.org/zh-cn/ nodejs下载安装，包含了npm，npm帮我们下载和管理第三方代码包 nodejs可以跑服务器，前端跑node为了模拟后台环境进行调试。当然nodejs可以开发服务器。 4.git 代码版本管理工具: https://gitforwindows.org/ window专享 强烈推荐在掘金和github都注册账号，开始你的技术之旅，记录的你成长轨迹！","link":"/newleaner.html"},{"title":"node generate pdf solutions(pdf 解决方案)","text":"当当当，今天分享下如何生成pfd一个高效的解决方案。在管理系统中，我们需要将页面的内容打印 PDF 和 excel。HTML 打印 PDF 有很多方法，比如先将页面转换成canvas，然后打印canvas等。今天我们介绍2个 npm包，来帮助我们打印出来我们想要的PDF。其实打印pdf这个事儿主要工作在后端，众所周知前端能够做的东西有限，有限，，， 思路1.在页面上点击打印，把需要打印的内容传送给后台 2.在后端生成对应页面的template（或者是先生成好的） 3.向template中填充前端传来的数据 4.生成用数据的 HTML 页面并打印 一. handlerbars官网: http://handlebarsjs.com/ 用这个包让我们可以把我们想要打的页面模版化。用handerbars在后台生成一个供我们打印pdf的 pdf.html 模版（调整好样式），随时等着前端发送打印请求。 下面介绍下handlerbars的基本用法。 以上demo来自官网，细节和语法请参照官网。 优点可以灵活的调整页面；可以注册函数，使用函数渲染列表；支持if／else渲染；如需要渲染图片，需用base64格式；学习成本低等 缺点需要在后台重新写一套样式 二.node-html-pdf Github: https://github.com/marcbachmann/node-html-pdf 又一个上手快的npm包，api简单明了,以下是核心代码 这里用到用 handerbars 生成的html，直接打印即可 。当然关于 pdf 页眉，页脚，缩放比例等的设置可以参考下 gitbub 里的说明。 以上两个npm包结合起来生成 pdf 再好用不过. PS：在生成打印 pdf 时，需用到分页打印。可用 page-break-before和page-break-after，这是CSS的一个属性哦, &lt;div style=&quot;page-break-before:always&quot;&gt;&lt;/div&gt;","link":"/nodepdf.html"},{"title":"padStart & padEnd","text":"在ES8中，为String新增 padStart &amp; padEnd， 用来填充字符串。 1.使用场景 生成统一位数的文件名、编号等；eg：0001.txt ～ 9999.txt 带有统一前缀或后缀的字符串、名字、编码等；eg：¥1,000.00，#EFEFEF，0x001F 生成位数一样的字符串，以便打印和显示。 2.语法str.padStart(targetLength [, padString]) 3.参数targetLength 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString 可选 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 “ “（U+0020）。 4.返回值 在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串 5.示例 'abc'.padStart(10); // &quot; abc&quot; 'abc'.padStart(10, &quot;foo&quot;); // &quot;foofoofabc&quot; 'abc'.padStart(6,&quot;123465&quot;); // &quot;123abc&quot; 'abc'.padStart(8, &quot;0&quot;); // &quot;00000abc&quot; 'abc'.padStart(1); // &quot;abc&quot; 6.源代码（polyfill 方法) if (!String.prototype.padStart) { String.prototype.padStart = function padStart(targetLength,padString) { targetLength = targetLength&gt;&gt;0; //floor if number or convert non-number to 0; padString = String((typeof padString !== 'undefined' ? padString : '')); if (this.length &gt; targetLength) { return String(this); } else { targetLength = targetLength–this.length; if (targetLength &gt; padString.length) { //append to original to ensure we are longer than needed padString += padString.repeat(targetLength/padString.length); } return padString.slice(0,targetLength) + String(this); } }; } padEnd 同理。 也可以用 lodash 相应的 padStart 和 padEnd 代替","link":"/padStart.html"},{"title":"rich editor(富文本编辑器)","text":"今天我们来介绍5个前端富文本编辑器 1.vue-quill-editor地址：https://github.com/surmon-china/vue-quill-editor 这款富文本编辑器，能搞定 vue 的 SPA 和 SSR 富文本编辑问题。使用起来很方便。文档易懂，要深入了解就要详细的看看quill的文档了，和quill一样可以通过注册组件来扩展功能。不过quill目前的release版本是1.3.6，vue-quill-editor依赖的是1.3.4 部分扩展组建用起来可能会有隐藏的bug。如果想深入了解推荐看1.3.4版本的quill。目前的版本改动较大。不过，这款编辑器和quill一样，对table的支持不太友好。扩展quilljs-table有蛮多bug，全选删除会留下一行表格，怎么都删不掉，该起来源代码也不那么容易。如果需要用到table功能，不建议使用quill系列的编辑器。 2.Quill 近2万颗星星的 富文本编辑器地址：https://quilljs.com/ quill是vue-quill-editor的核心，功能强大，如果想自己更灵活的使用编辑器可以直接使用quill，封装成自己的组件。没的说，除了table其它都很棒。目前quill正在集成table的相关功能，预计很快就可以添上这个坑了。 3.TinyMCE https://www.tiny.cloud/这款编辑器个人感觉比以上两款都要强大，很贴心的有两种模式。一个是普通模式，一个是inline模式。在inline模式中，在需要编辑时功能菜单可以浮动起来，在readonly时功能菜单隐藏。此编辑器对table友好（有没有很感动）。有些高级功能是需要付费的，详见官网。这个组件也有个小问题。场景：当插入图片后，把编辑的content保存起来，在其它标签或者标签内显示（非TinyMCE内）图片环绕着的文子会错位。这个很影响美观。不过从word 和 excel 复制粘贴过来的内容完全匹配。 line模式 4.wangEditor 国产轻量级编辑器使用起来很走心，很简单，中文文档详细 https://www.kancloud.cn/wangfupeng/wangeditor3/332599 学习成本较以上3个小了很多。table和图片处理都OK。近6000个star可以证明这款编辑器经过考验了。 5.UEditor 百度编辑器，符合国人习惯，强大的无可挑剔地址：http://fex.baidu.com/ueditor/#start-start 看图！ 有木有和word一摸一样。能想到的功能基本都有了。本人在wordpress 用的就是这个款编辑器。UEditor可以支持前后端集成，支持php，jsp等。如果项目中需要非常专业的编辑功能，这个编辑器肯定是首选了！","link":"/richEditor.html"},{"title":"参考资料","text":"一本前端雀语小册:https://www.yuque.com/robinson/fe-guide Pro githttp://iissnan.com/progit 全家福: 各大语言、框架技术传送门https://devdocs.io/","link":"/useful-tools-website.html"},{"title":"关于windows系统滚动条占位置的相关总结","text":"这是一个很蛋疼的问题，在window下会出现table出现滚动条，且把table-content的内容挤歪了，，，和浏览器无关，这个和操作系统有关系。网上有一些解决方案。在此不一一列举，或者写死columns的宽度，或者把滚动条width设置为0。不同的场景，需要调整的样式不同，所以在此仅总结相关知识。 1.判断window系统 这个window对象通常我们都 navigator.userAgent 用来判断浏览器类型，例如 //IE浏览器 if (userAgent.indexOf('NET') != -1 &amp;&amp; userAgent.indexOf(&quot;rv&quot;) != -1) { isIE = true; /*broName = 'IE浏览器'; */ strStart = userAgent.indexOf('rv'); strStop = userAgent.indexOf(')'); temp = userAgent.substring(strStart, strStop); broName = temp.replace('rv', 'IE').replace(':', '版本号'); } 此时我们用 platform 这个属性来判断电脑的操作系统 Navigator.platform 的返回值 “MacIntel”, “Win32”, “FreeBSD i386”, “WebTV OS” PS: Most browsers, including Chrome, Edge, and Firefox 63 and later, return “Win32” even if running on a 64-bit version of Windows. Internet Explorer and versions of Firefox prior to version 63 still report “Win64”. —- 来自Mozilla 所以我们判断 Win32 / Win64 就是 window操作系统， MacIntel 是 IOS 操作系统，”FreeBSD i386”, “WebTV OS”分别是嵌入式和linux（这两个不是很确定，若有正确答案请留言） 技巧： 在 index.html / index.js 中写入 document.documentElement.setAttribute('data-platform', navigator.platform)， html效果： 在css文件中 ，可以根据不同系统有不同表现： html[data-platform=&quot;Win32&quot;] { color: red; } html[data-platform=&quot;MacIntel&quot;] { color: blue; } 2.设置滚动条样式chrome（webkit) ::-webkit-scrollbar 滚动条整体部分 ::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或向左向右移动） ::-webkit-scrollbar-track 滚动条的轨道（里面装有Thumb） ::-webkit-scrollbar-button 滚动条的轨道的两端按钮，由于通过点击微调小方块的位置。 ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分 ::-webkit-scrollbar-corner 边角，即垂直滚动条和水平滚动条相交的地方 ::-webkit-resizer 两个滚动条的交汇处上用于拖动调整元素大小的小控件 sass写法 .scrollbarContainer { &amp;::-webkit-scrollbar { background-color: red; } &amp;::-webkit-scrollbar-track { background-color: blue; } &amp;::-webkit-scrollbar-thumb { background: #3DB6A4; } &amp;::-webkit-scrollbar-button:start { background-color: yellow; } &amp;::-webkit-scrollbar-button:end { background-color: palevioletred; } } IE （特殊的IE) scrollbar-arrow-color: color; /*三角箭头的颜色*/ scrollbar-face-color:color; /*立体滚动条的颜色*/ scrollbar-3dlight-color: color; /*立体滚动条亮边的颜色*/ scrollbar-highlight-color: color; /*滚动条空白部分的颜色*/ scrollbar-shadow-color: color; /*立体滚动条阴影的颜色*/ scrollbar-darkshadow-color: color; /*立体滚动条强阴影的颜色*/ scrollbar-track-color: color; /*立体滚动条背景颜色*/ scrollbar-base-color:color; /*滚动条的基本颜色*/","link":"/windows-table-scrollbar.html"},{"title":"vue key有个坑","text":"在vue2.x 中，我们经常使用key来提高组件性能，给了 input 或者 在 v-for 中 给子组件/元素一个 key 来加速diff渲染，这也是官方推荐的做法。不过 key 的赋值还真的不能马虎。 案例1. 无key的情况，切换 input 无法自动清空在 input 不加 key 的时候，切换这两个 input 标签，input 框框里的值不会变 案例2. key相同tag标签，多次出现在同一个页面这个bug很少见，但见了后会很头疼。通常我们使用key 偷懒的情况使用index来做key， &lt;div v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot; /&gt; 这样的key写多了，又同时进行渲染，在来个排序什么的，就很容易出现bug。最好 key + 时间戳 或者 使用唯一的key标示。 总结： key 要唯一 ！要唯一！要唯一! 另外一个渲染 input radio 显示不正确的问题 在以上代码，原本想点击Add one 渲染多个inputRadio 组件，从而进行Yes or No的选择。但以上有2个错误。 错误1. 在组件内部 id 不唯一。 在多次进行inputRadio时候会渲染多个id为yes 和 no的input组件。从而使label总绑定到第一个input上。 错误2. 在input中使用name时候，名字一样， 导致多次渲染inputRadio时候无法准确定位input。 正确代码可以将 id 和 name 加上时间戳编程唯一的 id / name。","link":"/vue-key.html"}],"tags":[{"name":"面试题","slug":"面试题","link":"/tags/面试题/"},{"name":"aem","slug":"aem","link":"/tags/aem/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"koa","slug":"koa","link":"/tags/koa/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"middleware","slug":"middleware","link":"/tags/middleware/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"helmet","slug":"helmet","link":"/tags/helmet/"},{"name":"solutions","slug":"solutions","link":"/tags/solutions/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"router","slug":"router","link":"/tags/router/"},{"name":"noSql","slug":"noSql","link":"/tags/noSql/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"sharing","slug":"sharing","link":"/tags/sharing/"},{"name":"pdf","slug":"pdf","link":"/tags/pdf/"},{"name":"es6+","slug":"es6","link":"/tags/es6/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"编辑器","slug":"编辑器","link":"/tags/编辑器/"},{"name":"富文本编辑器","slug":"富文本编辑器","link":"/tags/富文本编辑器/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"css-hack","slug":"css-hack","link":"/tags/css-hack/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"key","slug":"key","link":"/tags/key/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"mongodb","slug":"mongodb","link":"/categories/mongodb/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"css","slug":"css","link":"/categories/css/"}]}